name: 'Quick K8s'
description: 'Quickly deploy a k8s cluster on Github Actions hosted runners'
branding:
  icon: 'box'
  color: 'blue'
inputs:
  apiServerPort:
    description: 'The port to use for the Kubernetes API server'
    required: false
    default: '6443'
  apiServerAddress:
    description: 'The address to use for the Kubernetes API server'
    required: false
    default: '0.0.0.0'
  disableDefaultCni:
    description: 'Disable the default CNI plugin'
    required: false
    default: 'true'
  ipFamily:
    description: 'The IP family to use for the Kubernetes API server'
    required: false
    default: 'dual'
  defaultNodeImage:
    description: 'The default node image to use for the Kubernetes cluster'
    required: false
    default: 'kindest/node:v1.35.0@sha256:452d707d4862f52530247495d180205e029056831160e22870e37e3f6c1ac31f'
  numControlPlaneNodes:
    description: 'The number of control plane nodes to use for the Kubernetes cluster'
    required: false
    default: '1'
  numWorkerNodes:
    description: 'The number of worker nodes to use for the Kubernetes cluster'
    required: false
    default: '1'
  clusterProvider:
    description: 'Kubernetes cluster provider (kind or minikube)'
    required: false
    default: 'kind'
  kindVersion:
    description: 'The version of KinD to use'
    required: false
    default: 'v0.31.0'
  minikubeVersion:
    description: 'The version of Minikube to use'
    required: false
    default: 'v1.38.0'
  minikubeDriver:
    description: 'The driver to use for Minikube (docker, podman, none)'
    required: false
    default: 'docker'
  calicoVersion:
    description: 'The version of Calico to use'
    required: false
    default: 'v3.31.3'
  ocpReleaseLevel:
    description: 'The release level of OpenShift to use'
    required: false
    default: '4.20'
  installOLM:
    description: 'Install the Operator Lifecycle Manager'
    required: false
    default: 'false'
  removeDefaultStorageClass:
    description: 'Remove the default storage class'
    required: false
    default: 'false'
  removeControlPlaneTaint:
    description: 'Remove the control plane taint'
    required: false
    default: 'false'
  waitForPodsReady:
    description: 'Wait for all pods to be ready'
    required: false
    default: 'false'
  installIstio:
    description: 'Install Istio service mesh'
    required: false
    default: 'false'
  istioVersion:
    description: 'The version of Istio to install'
    required: false
    default: '1.28.3'
  istioProfile:
    description: 'Istio installation profile (minimal, demo, default, preview, ambient, empty)'
    required: false
    default: 'minimal'
  installCalico:
    description: 'Install Calico CNI when default CNI is disabled. Set to false to bring your own CNI (e.g., Multus, OVN)'
    required: false
    default: 'true'
  kindConfigPath:
    description: 'Path to custom KinD configuration file. When provided, uses this instead of auto-generated config'
    required: false
    default: ''
  installLocalRegistry:
    description: 'Install a local Docker registry accessible from the cluster'
    required: false
    default: 'false'
  localRegistryPort:
    description: 'Port for the local Docker registry'
    required: false
    default: '5001'

runs:
  using: 'composite'
  steps:
    - name: Validate cluster provider input
      shell: bash
      run: |
        if [[ "${{ inputs.clusterProvider }}" != "kind" && "${{ inputs.clusterProvider }}" != "minikube" ]]; then
          echo "Invalid cluster provider: ${{ inputs.clusterProvider }}"
          echo "Must be either 'kind' or 'minikube'"
          exit 1
        fi

    - name: Validate KinD version input
      if: ${{ inputs.clusterProvider == 'kind' }}
      shell: bash
      env:
        GITHUB_TOKEN: ${{ github.token }}
      run: |
        if ! [[ "${{ inputs.kindVersion }}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          echo "Invalid KinD version format: ${{ inputs.kindVersion }}"
          exit 1
        fi
        # Retry logic for flaky GitHub API calls with exponential backoff
        max_attempts=5
        attempt=1
        delay=2
        while [ $attempt -le $max_attempts ]; do
          http_code=$(curl --silent --output /dev/null --write-out "%{http_code}" -L -H "Authorization: token $GITHUB_TOKEN" https://api.github.com/repos/kubernetes-sigs/kind/releases/tags/${{ inputs.kindVersion }})
          if [ "$http_code" = "200" ]; then
            echo "KinD version ${{ inputs.kindVersion }} validated successfully"
            break
          fi
          if [ $attempt -eq $max_attempts ]; then
            if [ "$http_code" = "404" ]; then
              echo "KinD version ${{ inputs.kindVersion }} does not exist on GitHub"
            else
              echo "GitHub API failed to validate KinD version ${{ inputs.kindVersion }} (HTTP $http_code after $max_attempts attempts)"
              echo "This may be a temporary GitHub API issue - consider re-running the workflow"
            fi
            exit 1
          fi
          echo "Attempt $attempt/$max_attempts failed (HTTP $http_code), retrying in $delay seconds..."
          sleep $delay
          delay=$((delay * 2))
          attempt=$((attempt + 1))
        done

    - name: Validate Minikube version input
      if: ${{ inputs.clusterProvider == 'minikube' }}
      shell: bash
      env:
        GITHUB_TOKEN: ${{ github.token }}
      run: |
        if ! [[ "${{ inputs.minikubeVersion }}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          echo "Invalid Minikube version format: ${{ inputs.minikubeVersion }}"
          exit 1
        fi
        # Retry logic for flaky GitHub API calls with exponential backoff
        max_attempts=5
        attempt=1
        delay=2
        while [ $attempt -le $max_attempts ]; do
          http_code=$(curl --silent --output /dev/null --write-out "%{http_code}" -L -H "Authorization: token $GITHUB_TOKEN" https://api.github.com/repos/kubernetes/minikube/releases/tags/${{ inputs.minikubeVersion }})
          if [ "$http_code" = "200" ]; then
            echo "Minikube version ${{ inputs.minikubeVersion }} validated successfully"
            break
          fi
          if [ $attempt -eq $max_attempts ]; then
            if [ "$http_code" = "404" ]; then
              echo "Minikube version ${{ inputs.minikubeVersion }} does not exist on GitHub"
            else
              echo "GitHub API failed to validate Minikube version ${{ inputs.minikubeVersion }} (HTTP $http_code after $max_attempts attempts)"
              echo "This may be a temporary GitHub API issue - consider re-running the workflow"
            fi
            exit 1
          fi
          echo "Attempt $attempt/$max_attempts failed (HTTP $http_code), retrying in $delay seconds..."
          sleep $delay
          delay=$((delay * 2))
          attempt=$((attempt + 1))
        done

    - name: Validate Calico version input
      shell: bash
      env:
        GITHUB_TOKEN: ${{ github.token }}
      run: |
        if ! [[ "${{ inputs.calicoVersion }}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          echo "Invalid Calico version format: ${{ inputs.calicoVersion }}"
          exit 1
        fi
        # Retry logic for flaky GitHub API calls with exponential backoff
        max_attempts=5
        attempt=1
        delay=2
        while [ $attempt -le $max_attempts ]; do
          http_code=$(curl --silent --output /dev/null --write-out "%{http_code}" -L -H "Authorization: token $GITHUB_TOKEN" https://api.github.com/repos/projectcalico/calico/releases/tags/${{ inputs.calicoVersion }})
          if [ "$http_code" = "200" ]; then
            echo "Calico version ${{ inputs.calicoVersion }} validated successfully"
            break
          fi
          if [ $attempt -eq $max_attempts ]; then
            if [ "$http_code" = "404" ]; then
              echo "Calico version ${{ inputs.calicoVersion }} does not exist on GitHub"
            else
              echo "GitHub API failed to validate Calico version ${{ inputs.calicoVersion }} (HTTP $http_code after $max_attempts attempts)"
              echo "This may be a temporary GitHub API issue - consider re-running the workflow"
            fi
            exit 1
          fi
          echo "Attempt $attempt/$max_attempts failed (HTTP $http_code), retrying in $delay seconds..."
          sleep $delay
          delay=$((delay * 2))
          attempt=$((attempt + 1))
        done

    - name: Validate OpenShift release level input
      shell: bash
      run: |
        if ! [[ "${{ inputs.ocpReleaseLevel }}" =~ ^[0-9]+\.[0-9]+$ ]]; then
          echo "Invalid OpenShift release level format: ${{ inputs.ocpReleaseLevel }}"
          exit 1
        fi

    - name: Validate Istio version input
      if: ${{ inputs.installIstio == 'true' }}
      shell: bash
      env:
        GITHUB_TOKEN: ${{ github.token }}
      run: |
        if ! [[ "${{ inputs.istioVersion }}" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          echo "Invalid Istio version format: ${{ inputs.istioVersion }}"
          exit 1
        fi
        # Retry logic for flaky GitHub API calls with exponential backoff
        max_attempts=5
        attempt=1
        delay=2
        while [ $attempt -le $max_attempts ]; do
          http_code=$(curl --silent --output /dev/null --write-out "%{http_code}" -L -H "Authorization: token $GITHUB_TOKEN" https://api.github.com/repos/istio/istio/releases/tags/${{ inputs.istioVersion }})
          if [ "$http_code" = "200" ]; then
            echo "Istio version ${{ inputs.istioVersion }} validated successfully"
            break
          fi
          if [ $attempt -eq $max_attempts ]; then
            if [ "$http_code" = "404" ]; then
              echo "Istio version ${{ inputs.istioVersion }} does not exist on GitHub"
            else
              echo "GitHub API failed to validate Istio version ${{ inputs.istioVersion }} (HTTP $http_code after $max_attempts attempts)"
              echo "This may be a temporary GitHub API issue - consider re-running the workflow"
            fi
            exit 1
          fi
          echo "Attempt $attempt/$max_attempts failed (HTTP $http_code), retrying in $delay seconds..."
          sleep $delay
          delay=$((delay * 2))
          attempt=$((attempt + 1))
        done

    - name: Validate Istio profile input
      if: ${{ inputs.installIstio == 'true' }}
      shell: bash
      run: |
        VALID_PROFILES=("minimal" "demo" "default" "preview" "ambient" "empty")
        PROFILE="${{ inputs.istioProfile }}"
        if [[ ! " ${VALID_PROFILES[@]} " =~ " ${PROFILE} " ]]; then
          echo "Invalid Istio profile: $PROFILE"
          echo "Valid profiles are: ${VALID_PROFILES[*]}"
          exit 1
        fi

    - name: Validate installCalico input
      shell: bash
      run: |
        if [[ "${{ inputs.installCalico }}" != "true" && "${{ inputs.installCalico }}" != "false" ]]; then
          echo "Invalid installCalico value: ${{ inputs.installCalico }}"
          echo "Must be 'true' or 'false'"
          exit 1
        fi

    - name: Validate installLocalRegistry input
      shell: bash
      run: |
        if [[ "${{ inputs.installLocalRegistry }}" != "true" && "${{ inputs.installLocalRegistry }}" != "false" ]]; then
          echo "Invalid installLocalRegistry value: ${{ inputs.installLocalRegistry }}"
          echo "Must be 'true' or 'false'"
          exit 1
        fi

    - name: Validate localRegistryPort input
      if: ${{ inputs.installLocalRegistry == 'true' }}
      shell: bash
      run: |
        PORT="${{ inputs.localRegistryPort }}"
        if ! [[ "$PORT" =~ ^[0-9]+$ ]] || [ "$PORT" -lt 1024 ] || [ "$PORT" -gt 65535 ]; then
          echo "Invalid localRegistryPort: $PORT"
          echo "Must be a number between 1024 and 65535"
          exit 1
        fi

    - name: Validate kindConfigPath input
      if: ${{ inputs.kindConfigPath != '' && inputs.clusterProvider == 'kind' }}
      shell: bash
      run: |
        CONFIG_PATH="${{ inputs.kindConfigPath }}"
        if [ ! -f "$CONFIG_PATH" ]; then
          echo "Custom KinD config file not found: $CONFIG_PATH"
          exit 1
        fi
        echo "Using custom KinD configuration from: $CONFIG_PATH"

    - name: Validate number of control-plane nodes
      shell: bash
      run: |
        if [[ "${{ inputs.numControlPlaneNodes }}" -lt 1 ]]; then
          echo "The number of control-plane nodes cannot be less than 1."
          exit 1
        fi

    - name: Validate number of worker nodes
      shell: bash
      run: |
        if [[ "${{ inputs.numWorkerNodes }}" -lt 0 ]]; then
          echo "The number of worker nodes cannot be negative."
          exit 1
        fi

    - name: Check GitHub service status
      shell: bash
      run: ${{ github.action_path }}/scripts/check-github-status.sh

    - name: Write temporary docker file (Linux)
      if: ${{ runner.os == 'Linux' }}
      shell: bash
      run: |
        mkdir -p /home/runner/.docker
        touch /home/runner/.docker/config

    - name: Optimize disk space and relocate Docker storage (Linux)
      if: ${{ runner.os == 'Linux' }}
      uses: palmsoftware/quick-cleanup@v0
      with:
        cleanup-mode: auto
        minimum-free-space: 8

    - name: Setup Docker on Mac
      if: ${{ runner.os == 'macOS' }}
      uses: douglascamata/setup-docker-macos-action@v1.1.0

    # Cache KinD binary to avoid download failures during outages
    - name: Cache KinD binary
      if: ${{ inputs.clusterProvider == 'kind' }}
      id: cache-kind
      uses: actions/cache@v5
      with:
        path: /tmp/kind-binary
        key: kind-${{ inputs.kindVersion }}-${{ runner.os }}-${{ runner.arch }}

    # Install KinD binary (unified script for all platforms)
    - name: Install KinD
      if: ${{ inputs.clusterProvider == 'kind' }}
      shell: bash
      run: |
        OS=$(echo "${{ runner.os }}" | tr '[:upper:]' '[:lower:]')
        ${{ github.action_path }}/scripts/install-kind.sh ${{ inputs.kindVersion }} "$OS" ${{ runner.arch }}

    - name: Add error handling for KinD installation
      if: ${{ inputs.clusterProvider == 'kind' }}
      shell: bash
      run: |
        if ! command -v kind &> /dev/null; then
          echo "KinD installation failed. Exiting."
          exit 1
        fi

    # Cache Minikube binary to avoid download failures during outages
    - name: Cache Minikube binary
      if: ${{ inputs.clusterProvider == 'minikube' }}
      id: cache-minikube
      uses: actions/cache@v5
      with:
        path: /tmp/minikube-binary
        key: minikube-${{ inputs.minikubeVersion }}-${{ runner.os }}-${{ runner.arch }}

    # Install Minikube binary (unified script for all platforms)
    - name: Install Minikube
      if: ${{ inputs.clusterProvider == 'minikube' }}
      shell: bash
      run: |
        OS=$(echo "${{ runner.os }}" | tr '[:upper:]' '[:lower:]')
        ${{ github.action_path }}/scripts/install-minikube.sh ${{ inputs.minikubeVersion }} "$OS" ${{ runner.arch }}

    - name: Add error handling for Minikube installation
      if: ${{ inputs.clusterProvider == 'minikube' }}
      shell: bash
      run: |
        if ! command -v minikube &> /dev/null; then
          echo "Minikube installation failed. Exiting."
          exit 1
        fi

    # Create a new Kubernetes cluster using KinD
    - name: Populate temporary config file for KinD (auto-generated)
      if: ${{ inputs.clusterProvider == 'kind' && inputs.kindConfigPath == '' }}
      shell: bash
      run: ${{ github.action_path }}/scripts/generate-kind-config.sh ${{ inputs.apiServerPort }} ${{ inputs.apiServerAddress }} ${{ inputs.disableDefaultCni }} ${{ inputs.ipFamily }} ${{ inputs.defaultNodeImage }} ${{ inputs.numControlPlaneNodes }} ${{ inputs.numWorkerNodes }} ${{ github.action_path }}/kind-config.yaml

    - name: Use custom KinD config file
      if: ${{ inputs.clusterProvider == 'kind' && inputs.kindConfigPath != '' }}
      shell: bash
      run: |
        echo "Using custom KinD configuration from: ${{ inputs.kindConfigPath }}"
        cp "${{ inputs.kindConfigPath }}" "${{ github.action_path }}/kind-config.yaml"

    - name: Print the KinD config
      if: ${{ inputs.clusterProvider == 'kind' }}
      shell: bash
      run: cat ${{ github.action_path }}/kind-config.yaml

    - name: Configure Docker for Kubernetes (Linux)
      if: ${{ runner.os == 'Linux' }}
      shell: bash
      run: ${{ github.action_path }}/scripts/bootstrap-docker.sh

    - name: Final pre-cluster disk optimization
      if: ${{ runner.os == 'Linux' }}
      shell: bash
      run: ${{ github.action_path }}/scripts/pre-cluster-optimization.sh

    - name: Create a new Kubernetes cluster using KinD
      if: ${{ inputs.clusterProvider == 'kind' }}
      shell: bash
      run: kind create cluster --config ${{ github.action_path }}/kind-config.yaml

    - name: Create a new Kubernetes cluster using Minikube
      if: ${{ inputs.clusterProvider == 'minikube' }}
      shell: bash
      run: |
        ${{ github.action_path }}/scripts/start-minikube.sh \
          "${{ inputs.defaultNodeImage }}" \
          "${{ inputs.disableDefaultCni }}" \
          "${{ inputs.minikubeDriver }}" \
          "${{ inputs.apiServerPort }}" \
          "${{ inputs.numControlPlaneNodes }}" \
          "${{ inputs.numWorkerNodes }}"

    # - name: Bootstrap the runner with kubectl and oc clients
    - name: Bootstrap the runner with kubectl and oc clients
      if: ${{ runner.os == 'Linux' }}
      shell: bash
      run: |
        sudo ${{ github.action_path }}/scripts/install-oc-tools.sh --latest ${{ inputs.ocpReleaseLevel }}

    - name: Install oc client on MacOS
      if: ${{ runner.os == 'macOS' }}
      shell: bash
      run: |
        brew install openshift-cli
        brew install kubernetes-cli

    - name: Install calico CNI if default CNI is disabled and installCalico is true
      if: ${{ inputs.disableDefaultCni == 'true' && inputs.installCalico == 'true' }}
      shell: bash
      run: |
        echo "Installing Calico CNI version $CALICO_VERSION..."
        oc apply -f https://raw.githubusercontent.com/projectcalico/calico/$CALICO_VERSION/manifests/calico.yaml;
      env:
        CALICO_VERSION: ${{ inputs.calicoVersion }}

    - name: Skip CNI installation (bring your own CNI)
      if: ${{ inputs.disableDefaultCni == 'true' && inputs.installCalico == 'false' }}
      shell: bash
      run: |
        echo "⚠️  Skipping Calico CNI installation - installCalico is set to false"
        echo "   You must install your own CNI (e.g., Multus, OVN, Cilium) for the cluster to be functional"

    - name: Setup local Docker registry
      if: ${{ inputs.installLocalRegistry == 'true' }}
      shell: bash
      run: ${{ github.action_path }}/scripts/setup-local-registry.sh ${{ inputs.localRegistryPort }} ${{ inputs.clusterProvider }}

    - name: Install OLM
      if: ${{ inputs.installOLM == 'true' }}
      shell: bash
      run: ${{ github.action_path }}/scripts/install-olm.sh

    - name: Install Istio
      if: ${{ inputs.installIstio == 'true' }}
      shell: bash
      run: ${{ github.action_path }}/scripts/install-istio.sh ${{ inputs.istioVersion }} ${{ inputs.istioProfile }}

    - name: Remove the default storage class
      if: ${{ inputs.removeDefaultStorageClass == 'true' }}
      shell: bash
      run: |
        oc delete storageclass standard --ignore-not-found

    - name: Remove the control plane taint
      if: ${{ inputs.removeControlPlaneTaint == 'true' }}
      shell: bash
      run: |
        ${{ github.action_path }}/scripts/remove-control-plane-taint.sh

    - name: Wait for all pods to be ready
      if: ${{ inputs.waitForPodsReady == 'true' }}
      shell: bash
      run: ${{ github.action_path }}/scripts/wait-for-pods.sh

    - name: Clean up package manager cache (Linux)
      if: ${{ runner.os == 'Linux' }}
      shell: bash
      run: |
        sudo apt-get clean

    - name: Clean up Homebrew cache (macOS)
      if: ${{ runner.os == 'macOS' }}
      shell: bash
      run: |
        brew cleanup -s
        rm -rf ~/Library/Caches/Homebrew

    - name: Remove temporary files
      shell: bash
      run: |
        rm -f ${{ github.action_path }}/kind-config.yaml || true
        rm -f oc.tar.gz kind || true
